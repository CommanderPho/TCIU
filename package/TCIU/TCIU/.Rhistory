# put mask data into 1-p dataframe according to the x, y value
# so that at specific voxel the values for 1-p and mask value are fixed
mask_df$maskval = NA
idx = 1
for(j in unique(mask_df$y)){
for(i in unique(mask_df$x)){
mask_df$maskval[idx] = contour_mask_2d[i, j]
idx = idx + 1
}
}
pval_df = fmri_3dvisual(pval_3d, mask_3d, p_threshold,
method, color_pal = "YlOrRd",
multi_pranges)$pval_df
if (packageVersion("ggplot2") <= "3.2.1"){
contour_bin = 1
} else {
contour_bin = 2
}
# based on given method, make the integrated plot correspondingly
if (method %in% c("scale_p", "low5_percent")){
switch(method,
"scale_p" = {
# drop the corresponding rows if p value is larger than the given p_threshold
one_minus_p_df =  dplyr::filter(one_minus_p_df, one_minus_p >= 1 - p_threshold)
one_minus_p_df$p_val = 1 - one_minus_p_df$one_minus_p
if(nrow(one_minus_p_df) == 0){
stop("There does not exist any valid data under this 'p_threshold'. Please change a 'p_threshold' or change the method to 'low5_percent' and make 'p_threshold as NULL'.")
}
one_minus_p_df$cut_invs = wafflecut(one_minus_p_df$p_val,
c('[0,1e-8]', '(1e-8, 1e-7]', '(1e-7, 1e-6]', '(1e-6, 1e-5]',
'(1e-5, 1e-4]', '(1e-4, 1e-3]', '(1e-3, 1e-2]', '(1e-2, 5e-2]'))
one_minus_p_df$colorgrp = as.numeric(one_minus_p_df$cut_invs)
if(multi_pranges == FALSE){
one_minus_p_df$cut_invs = wafflecut(one_minus_p_df$p_val,
c('[0,1e-7]', '(1e-7, 1e-5]',
'(1e-5, 1e-3]', '(1e-3, 5e-2]'))
one_minus_p_df$colorgrp= as.numeric(one_minus_p_df$cut_invs)
}
},
"low5_percent" = {
one_minus_p_df$p_val = 1 - one_minus_p_df$one_minus_p
quantile5_pt = quantile(one_minus_p_df$p_val, 0.05)
one_minus_p_df = dplyr::filter(one_minus_p_df, p_val <= quantile5_pt)
p_val_max_minus_min = max(one_minus_p_df$p_val)-min(one_minus_p_df$p_val)
if (p_val_max_minus_min != 0){
cut_pts = min(one_minus_p_df$p_val) + 0:9 * (p_val_max_minus_min) / 9
cut_pts[length(cut_pts)] = ceiling_dec(cut_pts[length(cut_pts)], 2)
cut_pts[1] = floor_dec(cut_pts[1], 2)#
# add lapply to cut pts[2:-1] to round 3
cut_pts = unique(sapply(cut_pts, function(x) round(x, 3)))
invs_total = levels(cut(one_minus_p_df$p_val, cut_pts, right=TRUE))
invs_total[1] = sub("\\(", "[", invs_total[1])
one_minus_p_df$cut_invs = wafflecut(one_minus_p_df$p_val, invs_total)
one_minus_p_df$colorgrp = as.numeric(one_minus_p_df$cut_invs)##
}else{
one_minus_p_df$cut_invs = as.character(round(min(one_minus_p_df$p_val), 3))
for (i in unique(pval_df$cut_invs)){
if(length(levels(wafflecut(as.numeric(unique(one_minus_p_df$cut_invs)),
c(as.character(i))))) == 1){
one_minus_p_df$colorgrp = unique(pval_df[which(pval_df$cut_invs==i),]$colorgrp)
}
}
}
}
)
one_minus_p_df = merge(x = one_minus_p_df,
y = unique(pval_df%>%dplyr::select(colorgrp, corresp_color)),
by = "colorgrp")
motorinbrain =
ggplot() +
geom_tile(one_minus_p_df, mapping=aes(x=x, y=y, fill=corresp_color)) +
scale_fill_identity("p value",
labels= rev(as.character(unique(one_minus_p_df$cut_invs))),
breaks = sort(unique(one_minus_p_df$corresp_color),
decreasing = TRUE),
guide = "legend") +
plot_lab +
geom_contour(mask_df, mapping = aes(x=x, y=y, z=maskval),
colour = "black", bins = contour_bin, size=0.75) +
ggtitle(title) + theme(plot.title = element_text(hjust = 0.5))
}else if (method == "min_max"){
# drop the corresponding rows if p value is larger than the given p_threshold
one_minus_p_df =  dplyr::filter(one_minus_p_df, one_minus_p >= 1 - p_threshold)
one_minus_p_df$p_val = 1 - one_minus_p_df$one_minus_p
if(nrow(one_minus_p_df) == 0){
stop("There does not exist any valid data under this 'p_threshold'. Please change a 'p_threshold' or change the method to 'low5_percent' and make 'p_threshold as NULL'.")
}
idx = one_minus_p_df$one_minus_p != 0
one_minus_p_min = min(one_minus_p_df$one_minus_p[idx])
one_minus_p_max = max(one_minus_p_df$one_minus_p[idx])
break_pt = c(one_minus_p_min, (one_minus_p_min+one_minus_p_max)/2, one_minus_p_max)
motorinbrain =
ggplot() +
geom_tile(one_minus_p_df, mapping = aes(x=x, y=y, fill=one_minus_p, alpha=one_minus_p)) +
scale_alpha(range = c(0, 1), guide=F) +
plot_lab +
scale_fill_gradient(low = "yellow", high = "red",
limits=c(break_pt[1], break_pt[length(break_pt)]),
oob=squish, breaks=break_pt,
labels=format(round(1-break_pt, 4), nsmall = 4)) +
geom_contour(mask_df, mapping = aes(x=x, y=y, z=maskval),
colour = "black", bins = contour_bin, size=0.75) +
ggtitle(title) + theme(plot.title = element_text(hjust = 0.5))
}
# manage hemody data to make it dataframe for the plot
if(is.null(hemody_data) == FALSE){
# unsmooth data for blood flow in brain
contour_hemody_df$modval = NA
idx = 1
for(j in unique(contour_hemody_df$y)){
for(i in unique(contour_hemody_df$x)){
contour_hemody_df$modval[idx] = contour_hemody_2d[i, j]
idx = idx + 1
}
}
motorinbrain = motorinbrain +
geom_contour(contour_hemody_df, mapping = aes(x=x, y=y, z=modval),
colour = "blue4", bins = 8, size=0.7)
}
# decide whehter the final plot include the legend or not
if(legend_show){
return(motorinbrain + coord_fixed())
get_legend(motorinbrain)
}else{
return(motorinbrain + coord_fixed() +
theme(legend.position="none"))
}
}
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
install.packages("ggplot2", lib="D:/R-3.6.2/library")
install.packages("ggplot2", lib = "D:/R-3.6.2/library")
install.packages("ggplot2", lib = "D:/R-3.6.2/library")
detach("package:oro.nifti", unload = TRUE)
install.packages("ggplot2", lib="D:/R-3.6.2/library")
install.packages("ggplot2", lib = "D:/R-3.6.2/library")
library(ggplot2, lib.loc = "D:/R-3.6.2/library")
packageVersion("ggplot2")
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
require(dplyr)
require(RColorBrewer)
require(pracma)
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
require(fancycut)
require(scales
)
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
detach("package:ggplot2", unload = TRUE)
library(ggplot2, lib.loc = "D:/R-3.6.2/library")
library(TCIU, lib.loc = "D:/R-3.6.2/library")
require(oro.nifti)
# In this example, we generate three plots of the brain with activated area
# from sagittal, coronal and axial view.
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIU", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIU", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# plot the sagittal, coronal and axial view of this p value generated from the brain fMRI data
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
remove.packages("ggplot2", lib="D:/R-3.6.2/library")
install.packages("E:/Desktop/ggplot2_3.2.1.tar.gz", repos = NULL, type = "source", lib="D:/R-3.6.2/library")
library(TCIU, lib.loc = "D:/R-3.6.2/library")
require(oro.nifti)
# In this example, we generate three plots of the brain with activated area
# from sagittal, coronal and axial view.
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIU", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIU", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# plot the sagittal, coronal and axial view of this p value generated from the brain fMRI data
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
install.packages("ggplot2", lib="D:/R-3.6.2/library")
library(TCIU, lib.loc = "D:/R-3.6.2/library")
require(oro.nifti)
# In this example, we generate three plots of the brain with activated area
# from sagittal, coronal and axial view.
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIU", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIU", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# plot the sagittal, coronal and axial view of this p value generated from the brain fMRI data
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="min_max",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
library(TCIU, lib.loc = "D:/R-3.6.2/library")
require(oro.nifti)
# In this example, we generate three plots of the brain with activated area
# from sagittal, coronal and axial view.
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIU", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIU", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# plot the sagittal, coronal and axial view of this p value generated from the brain fMRI data
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {20},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {20},
"y" = {30},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
require(oro.nifti)
# In this example, we generate 6 subplots (2 rows * 3columns) based on two 3D array p value data
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIUtry", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value stored in the package
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIUtry", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# generated simulated fMRI data and get its p value based on t test
fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask,
ons = c(1, 21, 41, 61, 81, 101, 121, 141),
dur = c(10, 10, 10, 10, 10, 10, 10, 10))
# get p value by applying activation detection function on our simulated fMRI data using t test
p_simulate_ttest_raw =
stimulus_detect(fmridata= fmri_generate$fmri_data,
mask = fmri_generate$mask,
stimulus_idx = fmri_generate$on_time,
method = "t-test" ,
ons = fmri_generate$ons,
dur = fmri_generate$dur)
# make the 2D comparison plot between the p value stored in the pacakage and
# the p value generated based on simulated fMRI data
pval_comparison.2d(list(pval, p_simulate_ttest_raw),
list('pval', 'p_simulate'),
list(list(40, 26, 33), list(35, 33, 20)),
hemody_data = NULL,
mask_3d = mask, p_threshold = 0.05,
legend_show = FALSE, method = 'scale_p',
color_pal = "YlOrRd", multi_pranges=TRUE)
require(oro.nifti)
# In this example, we generate 6 subplots (2 rows * 3columns) based on two 3D array p value data
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIU", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value stored in the package
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIU", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# generated simulated fMRI data and get its p value based on t test
fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask,
ons = c(1, 21, 41, 61, 81, 101, 121, 141),
dur = c(10, 10, 10, 10, 10, 10, 10, 10))
# get p value by applying activation detection function on our simulated fMRI data using t test
p_simulate_ttest_raw =
stimulus_detect(fmridata= fmri_generate$fmri_data,
mask = fmri_generate$mask,
stimulus_idx = fmri_generate$on_time,
method = "t-test" ,
ons = fmri_generate$ons,
dur = fmri_generate$dur)
# make the 2D comparison plot between the p value stored in the pacakage and
# the p value generated based on simulated fMRI data
pval_comparison.2d(list(pval, p_simulate_ttest_raw),
list('pval', 'p_simulate'),
list(list(40, 26, 33), list(35, 33, 20)),
hemody_data = NULL,
mask_3d = mask, p_threshold = 0.05,
legend_show = FALSE, method = 'scale_p',
color_pal = "YlOrRd", multi_pranges=TRUE)
require(oro.nifti)
# In this example, we generate 6 subplots (2 rows * 3columns) based on two 3D array p value data
# load 3D nifti data of mask
fp_mask = system.file("extdata", "mask.nii.gz", package = "TCIU", mustWork=TRUE)
mask = readNIfTI(fp_mask)
# load 3D nifti data of p value stored in the package
fp_pval = system.file("extdata", "pval.nii.gz", package = "TCIU", mustWork=TRUE)
pval = readNIfTI(fp_pval)[,,]
# generated simulated fMRI data and get its p value based on t test
fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask,
ons = c(1, 21, 41, 61, 81, 101, 121, 141),
dur = c(10, 10, 10, 10, 10, 10, 10, 10))
# get p value by applying activation detection function on our simulated fMRI data using t test
p_simulate_ttest_raw =
stimulus_detect(fmridata= fmri_generate$fmri_data,
mask = fmri_generate$mask,
stimulus_idx = fmri_generate$on_time,
method = "t-test" ,
ons = fmri_generate$ons,
dur = fmri_generate$dur)
# make the 2D comparison plot between the p value stored in the pacakage and
# the p value generated based on simulated fMRI data
pval_comparison.2d(list(pval, p_simulate_ttest_raw),
list('pval', 'p_simulate'),
list(list(40, 26, 33), list(35, 30, 22)),
hemody_data = NULL,
mask_3d = mask, p_threshold = 0.05,
legend_show = FALSE, method = 'scale_p',
color_pal = "YlOrRd", multi_pranges=TRUE)
pval_comparison.2d(list(pval, p_simulate_ttest_raw),
+                    list('pval', 'p_simulate'),
+                    list(list(40, 26, 33), list(35, 30, 22)),
+                    hemody_data = NULL,
+                    mask_3d = mask, p_threshold = 0.05,
+                    legend_show = FALSE, method = 'scale_p',
+                    color_pal = "YlOrRd", multi_pranges=TRUE)
for(axis in c("x", "y", "z")){
axis_i = switch(axis,
"x" = {40},
"y" = {23},
"z" = {33})
print(fmri_2dvisual(pval, list(axis, axis_i),
hemody_data=NULL, mask, 0.005,
legend_show=TRUE, method="scale_p",
color_pal = "YlOrRd", multi_pranges=TRUE))
}
packageVersion("ggplot2")
packageVersion("ggplot2") <= "3.2.1"
？ KL_divergence
citation()
library(TCIU, lib.loc = "D:/R-3.6.2/library")
TCIU::demo_func()
demo(package = "TCIU")
demo("demo_func",package = "TCIU")
library(TCIU, lib.loc = "D:/R-3.6.2/library")
library(TCIU, lib.loc = "D:/R-3.6.2/library")
updateR()
library("installr")
install.packages("installr")
require(installr)
updateR()
updateR()
version()
version
library(abind)
detach("package:abind", unload = TRUE)
remove.packages("TCIU")
remove.packages("TCIUBasic")
install.packages("abind", "AnalyzeFMRI", "animation")
library(AnalyzeFMRI)
install.packages("R.matlab")
install.packages("AnalyzeFMRI")
install.packages("zoo")
install.packages("abind")
install.packages("animation")
install.packages("arm", "askpass", "aws", "backports")
install.packages("askpass")
install.packages("arm")
install.packages("plotly")
install.packages("ggplot2")
install.packages("devtools")
library("devtools")
install.packages("prettyunits")
library("devtools")
install.packages("desc")
library("devtools")
install.packages("rprojroot")
install.packages("cli ")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("DT")
install.packages("rversions ")
install.packages("rversions")
install.packages("stats")
install.packages("stats")
library(devtools)
install.packages("backports")
Sys.which("make")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
install.packages("E:/Desktop/TCIU_1.0.0.tar.gz", repos = NULL, type = "source")
install.packages("E:/Desktop/TCIU_1.0.0.tar.gz", repos = NULL, type = "source")
library(TCIU)
require(reshape2)
require(ggplot2)
# drop the first row and first column because of divergence on Laplace Transform
x = seq(0, 2, length.out=50)[2:50]; y = seq(0, 2, length.out=50)[2:50];
# do kimesurface transform on sine function
z2_grid = kimesurface_transform(FUNCT = function(t) { sin(t) },
real_x = x, img_y = y)
time_points = seq(0+0.001, 2*pi, length.out = 160)
inv_data = inv_kimesurface_transform(time_points, z2_grid)
time_Intensities_ILT_df2 <- as.data.frame(cbind(Re=scale(Re(inv_data$Smooth_Reconstruction)),
Im=scale(Re(inv_data$Raw_Reconstruction)),
fMRI=scale(Re(sin(time_points))),
time_points=time_points))
colnames(time_Intensities_ILT_df2) = c("Smooth Reconstruction",
"Raw Reconstruction",
"Original sin()",
"time_points")
df = reshape2::melt(time_Intensities_ILT_df2, id.var = "time_points")
ggplot(df, aes(x = time_points, y = value, colour = variable)) +
geom_line(linetype=1, lwd=3) +
ylab("Function Intensity") + xlab("Time") +
theme(legend.position="top")+
labs(title=
"Comparison between f(t)=sin(t) and SplineSmooth(ILT(LT(sin)))(t); Range [0 : 2pi]")
install.packages("E:/Desktop/TCIU_1.0.0.tar.gz", repos = NULL, type = "source")
library(TCIU)
setwd("E:/Desktop/6_24")
devtools::build_vignettes()
devtools::build_vignettes()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build()
install.packages("E:/Desktop/TCIU_1.0.0.tar.gz", repos = NULL, type = "source")
